// Generated by CoffeeScript 1.3.3

(function(window, $) {
  var TabIndent;
  TabIndent = (function() {

    TabIndent.version = "0.1.0";

    TabIndent.newLine = /\n/;

    TabIndent.autobind = function(selector) {
      var _this = this;
      if (selector == null) {
        selector = ".tabIndent";
      }
      if (typeof selector === "string") {
        $(document.body).on("focus.tabIndent", "" + selector, function(e) {
          var $el;
          $el = $(e.currentTarget);
          if (!$el.data('tabIndent')) {
            return $el.data('tabIndent', new _this({
              el: $el
            }));
          }
        });
        return this;
      } else {
        throw new SyntaxError("Invalid selector.");
      }
    };

    TabIndent.unautobind = function(selector) {
      if (selector == null) {
        selector = ".tabIndent";
      }
      if (typeof selector === "string") {
        $(document.body).off("focus.tabIndent", "" + selector);
        return this;
      } else {
        throw new SyntaxError("Invalid selector.");
      }
    };

    function TabIndent(params) {
      this.params = params;
      this.$el = params.el;
      this.el = params.el.get(0);
      this.bindEvents();
    }

    TabIndent.prototype.bindEvents = function() {
      var _this = this;
      this.$el.off("focus.tabIndent", function() {
        return _this.bindEvents();
      });
      this.$el.on("keydown.tabIndent", function(e) {
        var affectedRows, current, indent, lastLine, length, lowerBound, newCurrent, startIndices;
        current = {
          start: _this.el.selectionStart,
          end: _this.el.selectionEnd
        };
        if (e.keyCode === 9 || (e.keyCode === 221 && e.metaKey)) {
          e.preventDefault();
          if (_this.isMultiLine()) {
            startIndices = _this.findStartIndices();
            length = startIndices.length;
            newCurrent = {
              start: void 0,
              end: void 0
            };
            affectedRows = 0;
            while (length--) {
              lowerBound = startIndices[length];
              if (startIndices[length + 1] && current.start !== startIndices[length + 1]) {
                lowerBound = startIndices[length + 1];
              }
              if (lowerBound >= current.start && startIndices[length] < current.end) {
                _this.el.value = _this.el.value.slice(0, startIndices[length]) + "\t" + _this.el.value.slice(startIndices[length]);
                newCurrent.start = startIndices[length];
                if (!newCurrent.end) {
                  newCurrent.end = startIndices[length + 1] ? startIndices[length + 1] - 1 : 'end';
                }
                affectedRows++;
              }
            }
            _this.el.selectionStart = newCurrent.start;
            _this.el.selectionEnd = newCurrent.end !== "end" ? newCurrent.end + affectedRows : _this.el.value.length;
          } else {
            _this.el.value = _this.el.value.slice(0, current.start) + "\t" + _this.el.value.slice(current.start);
            _this.el.selectionStart = current.start + 1;
            _this.el.selectionEnd = current.end + 1;
          }
          return false;
        } else if (e.keyCode === 219 && e.metaKey) {
          e.preventDefault();
          if (_this.isMultiLine()) {
            startIndices = _this.findStartIndices();
            length = startIndices.length;
            newCurrent = {
              start: void 0,
              end: void 0
            };
            affectedRows = 0;
            while (length--) {
              lowerBound = startIndices[length];
              if (startIndices[length + 1] && current.start !== startIndices[length + 1]) {
                lowerBound = startIndices[length + 1];
              }
              if (lowerBound >= current.start && startIndices[length] < current.end) {
                if (_this.el.value.substr(startIndices[length], 1) === '\t') {
                  _this.el.value = _this.el.value.slice(0, startIndices[length]) + _this.el.value.slice(startIndices[length] + 1);
                  affectedRows++;
                }
                newCurrent.start = startIndices[length];
                if (!newCurrent.end) {
                  newCurrent.end = startIndices[length + 1] ? startIndices[length + 1] - 1 : "end";
                }
              }
            }
            _this.el.selectionStart = newCurrent.start;
            return _this.el.selectionEnd = newCurrent.end !== "end" ? newCurrent.end - affectedRows : _this.el.value.length;
          } else {
            if (_this.el.value.substr(current.start - 1, 1) === '\t') {
              _this.el.value = _this.el.value.substr(0, current.start - 1) + _this.el.value.substr(current.start);
              _this.el.selectionStart = current.start - 1;
              return _this.el.selectionEnd = current.end - 1;
            } else {
              _this.el.value = _this.el.value.substr(0, current.start) + _this.el.value.substr(current.start + 1);
              _this.el.selectionStart = current.start;
              return _this.el.selectionEnd = current.end - 1;
            }
          }
        } else if (e.keyCode === 13) {
          e.preventDefault();
          lastLine = _this.el.value.substr(0, current.start).split('\n').pop();
          indent = lastLine.match(/^\s*/)[0];
          _this.el.value = _this.el.value.slice(0, current.start) + ("\n" + indent) + _this.el.value.slice(current.end, _this.el.value.length);
          _this.el.selectionStart = current.start + 1 + indent.length;
          return _this.el.selectionEnd = _this.el.selectionStart;
        } else if (e.keyCode === 27) {
          return _this.unbindEvents();
        }
      });
      return this.$el.addClass("tabIndented");
    };

    TabIndent.prototype.unbindEvents = function() {
      var _this = this;
      this.$el.off(".tabIndent");
      this.$el.on("focus.tabIndent", function() {
        return _this.bindEvents();
      });
      return this.$el.removeClass("tabIndented");
    };

    TabIndent.prototype.isMultiLine = function() {
      var snippet;
      snippet = this.el.value.slice(this.el.selectionStart, this.el.selectionEnd);
      return TabIndent.newLine.test(snippet);
    };

    TabIndent.prototype.findStartIndices = function() {
      var lineEnd, offset, startIndices, text;
      text = this.el.value;
      startIndices = [];
      offset = 0;
      while (text.match(TabIndent.newLine) && text.match(TabIndent.newLine).length > 0) {
        offset = startIndices.length > 0 ? startIndices[startIndices.length - 1] : 0;
        lineEnd = text.search("\n");
        startIndices.push(lineEnd + offset + 1);
        text = text.substring(lineEnd + 1);
      }
      startIndices.unshift(0);
      return startIndices;
    };

    return TabIndent;

  })();
  $.tabIndent = TabIndent;
  return $.fn.tabIndent = function(options) {
    return this.each(function() {
      var $el, data;
      $el = $(this);
      data = $el.data('tabIndent');
      if (data) {
        if (typeof options === "string") {
          return data[options]();
        }
      } else {
        return $el.data('tabIndent', new TabIndent($.extend(options, {
          el: $el
        })));
      }
    });
  };
})(window, jQuery);
